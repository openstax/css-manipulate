const assert = require('assert')
const csstree = require('css-tree')
const Engine = require('./engine')
const serializer = require('./serializer')
const DECLARATIONS = require('./declarations')
const FUNCTIONS = require('./functions')
const {PSEUDO_ELEMENTS, PSEUDO_CLASSES} = require('./selectors')
const {init: errorInit, throwBug, throwError, showWarning, showError, showLog, sendElementCount} = require('./helper/packet-builder')

const constructSelector = require('./helper/construct-selector')



module.exports = (document, $, cssContents, cssSourcePath, htmlSourcePath, consol, htmlSourceLookup, htmlSourceFilename, sourceMapPath, rewriteSourceMapsFn, options) => {

  errorInit(consol, htmlSourceLookup, htmlSourcePath, options)

  const engine = new Engine(document, $, options)

  engine.setCSSContents(cssContents, cssSourcePath)


  // Add all the language plugins
  PSEUDO_ELEMENTS.forEach(engine.addPseudoElement.bind(engine))
  PSEUDO_CLASSES.forEach(engine.addPseudoClass.bind(engine))
  DECLARATIONS.forEach(engine.addRuleDeclaration.bind(engine))
  FUNCTIONS.forEach(engine.addFunction.bind(engine))


  count = 0
  function walkDOMElementsInOrder(el, index, acc, fn) {
    acc = fn(el, index, acc)
    count += 1
    if (el.firstElementChild) {
      walkDOMElementsInOrder(el.firstElementChild, 1, acc, fn)
    }
    if (el.nextElementSibling) {
      walkDOMElementsInOrder(el.nextElementSibling, index + 1, acc, fn)
    }
  }
  walkDOMElementsInOrder(document.documentElement, 1, '', (el, index, acc) => {
    const selector = constructSelector(el)
    el.__sourceSelector = selector
    // console.log(`chrome: ${selector}`);
  })
  // console.log('qiweuyqiuwye chromecount=' + count);
  sendElementCount(count)



  htmlSourceLookup = (node) => {
    if (!node) {
      throwBug('Expected node, but got nothing')
    }
    if (!node.__sourceSelector && node.nodeType === 1 /*ELEMENT_NODE*/) {
      if (!node.__cssLocation) {
        throwBug(`Found a node with no sourceSelector. Could be an autogenerated node. The selector might be: "${constructSelector(node)}"`, null, [node])
      } else {
        return null // It has a CSS location so we are OK
      }
    }
    const source = window.__HTML_SOURCE_LOOKUP[node.__sourceSelector]
    if (source) {
      const [line, col] = source
      return {line, col}
    } else {
      if (node.__sourceSelector === 'head') {
        showWarning('Could not find source for this element. It seems the original XHTML did not have a <head> but that is invalid XHTML', null, [node], null)
      } else if (node.nodeType === 1 /*ELEMENT_NODE*/) {
        showWarning('Could not find source for this element', null, [node], null)
      } else {
        // Do nothing. it's an attribute, text, comment, etc
        // TODO: Support sourcemap lookup of text nodes, attributes, etc
      }
      return null
    }

  }


  engine.prepare(rewriteSourceMapsFn)
  // console.profile('CPU Profile')
  const allElementsDoneProcessingPromise = engine.process()
  // console.profileEnd()

  // Types of Promises we need:
  // - create a DOM node (for pseudo-elements)
  // - attach the new DOM node at the correct spot
  // - assign a set of attributes to a DOM node
  // - assign the contents of a DOM node

  return allElementsDoneProcessingPromise.then(() => {
    return serializer(engine, htmlSourceLookup, htmlSourcePath, htmlSourceFilename, sourceMapPath, document, $)
  })
}
