const renderPacket = require('./render-packet')

let _console = console
let _htmlSourceLookup
let _htmlSourcePath
let _options = {}
let _hasBeenWarned = false

function init(consol, htmlSourceLookup, htmlSourcePath, options) {
  _console = consol
  _htmlSourceLookup = htmlSourceLookup
  _htmlSourcePath = htmlSourcePath
  _options = options
}

function cssSnippetToJson(cssSnippet) {
  // matches input format for https://github.com/feross/snazzy
  if (cssSnippet && cssSnippet.loc) {
    // Commented out the end lookup because when the CSS ast is rewritten with the original source coordinates this data is not present most of the time
    const {source: cssSourcePath, start: {line: startLine, column: startColumn}/*, end: {line: endLine, column: endColumn}*/} = cssSnippet.loc
    return {filename: cssSourcePath, location: [startLine, startColumn + 1]} // columns start with 0 (lines start with 1)
  } else {
    return {filename: 'unknownCSSFile', location: [0, 0], additional: JSON.stringify(cssSnippet)}
  }
}


function constructSelector(el) {
  if (!el) {
    return 'NULL'
  } else if (el.tagName.toLowerCase(el) === 'html') {
    return 'html'
  } else if (el.tagName.toLowerCase(el) === 'body') {
    return 'body'
  } else if (el.hasAttribute('id')) {
    return `${el.tagName.toLowerCase()}#${el.getAttribute('id')}`
  } else if (el.className) {
    return `${constructSelector(el.parentElement)} > ${el.tagName.toLowerCase()}.${el.className.split(' ').join('.')}`
  } else if (el.hasAttribute('data-type')) {
    return `${constructSelector(el.parentElement)} > ${el.tagName.toLowerCase()}[data-type="${el.getAttribute('data-type')}"]`
  } else {
    return `${constructSelector(el.parentElement)} > ${el.tagName.toLowerCase()}`
  }
}

// Generate pretty messages with source lines for debugging
function sendLintMessage(severity, message, cssSnippet, $el, additionalCssSnippet) {
  _console.info(JSON.stringify({
    type: 'LINT',
    severity: severity,
    message: message,
    css_file_info: cssSnippet && cssSnippetToJson(cssSnippet),
    additional_css_file_info: additionalCssSnippet && cssSnippetToJson(additionalCssSnippet),
    html_file_info: $el && $el[0] && htmlLocation($el[0])
  }))
}



function htmlLocation(el) {
  if (el) {
    if (_htmlSourceLookup) {
      const locationInfo = _htmlSourceLookup(el)
      function getLocationString() {
        if (locationInfo.line !== null && typeof(locationInfo.line) !== 'undefined') {
          return {filename: _htmlSourcePath, location: [locationInfo.line, locationInfo.col]}
        } else {
          const selector = constructSelector(el)
          return {filename: _htmlSourcePath, location: selector}
        }
      }
      if (locationInfo) {
        // ELements like <body> do not have location information
        const htmlDetails = getLocationString()
        return htmlDetails
      }
    }
    // no lookup info present. It could be an element that was generated by CSS
    if (el.__cssLocation) {
      return cssSnippetToJson(el.__cssLocation)
    } else {
      const selector = constructSelector(el)
      return {filename: _htmlSourcePath, location: selector}
    }
  } else {
    return 'unknown'
  }
}

function throwError(message, cssSnippet, $el, err) {
  sendLintMessage('ERROR', message, cssSnippet, $el)
  if (err) {
    throw err
  } else {
    throw new Error(message)
  }
}

function throwBug(message, cssSnippet, $el, err) {
  sendLintMessage('BUG', message, cssSnippet, $el)
  if (err) {
    throw err
  } else {
    throw new Error(message)
  }
}

const displayedWarningCache = {} // Only show a warning for a particular source line once. Otherwise it is annoying
function showWarning(message, cssSnippet, $el, additionalCssSnippet) {
  const key = `${cssSnippetToJson(cssSnippet)} | ${message}`
  if (!displayedWarningCache[key] || _options.verbose) {
    sendLintMessage('WARN', message, cssSnippet, $el, additionalCssSnippet)
    displayedWarningCache[key] = true
  }
}

function showLog(message, cssSnippet, $el) {
  sendLintMessage('LOG', message, cssSnippet, $el)
}


function showDebuggerData($currentEl, debugMatchedRules, debugAppliedDeclarations, $debuggingEl, toBrowserSelector) {
  _console.info(JSON.stringify({
    type: 'DEBUG_ELEMEMT',
    html_file_info: htmlLocation($debuggingEl[0]),
    context_html_file_info: ($currentEl[0] !== $debuggingEl[0]) && htmlLocation($currentEl[0]), // only include when context is different than the current element
    selectors: debugMatchedRules.map((matchedRule) => {
      const {rule, selector} = matchedRule.getRule()
      return {
        css_file_info: cssSnippetToJson(rule),
        browser_selector: toBrowserSelector(selector, true /*includePseudoElements*/)
      }
    }),
    declarations: debugAppliedDeclarations.map(({declaration, vals}) => {
      return {
        css_file_info: cssSnippetToJson(declaration.astNode),
        name: declaration.astNode.property,
        value:
            // vals is a 2-dimensional array
            vals.map((val) => {
              return val.map((v2) => {
                if (typeof v2 === 'string') {
                  return v2
                } else if (typeof v2 === 'number') {
                  return v2
                } else if (v2.jquery) {
                  return v2.toArray().map((el) => {
                    return htmlLocation(el)
                  })
                } else {
                  debugger
                  return v2
                }
              })
            })
      }
    })
  }))
}


function assert(val, astNode, $el) {
  if (!astNode || !$el) {
    throwBug(`Missing argument to assert`, astNode, $el)
    debugger // here so we can diagnose the assertion
    throw new Error('Missing argument to assert. Throwing for stacktrace')
  }
  if (!val) {
    throwBug('Assertion failed', astNode, $el)
    debugger // here so we can diagnose the assertion
    throw new Error('Assertion failed. Throwing for stacktrace')
  }
}
assert.equal = function(expected, actual, astNode, $el) {
  if (expected !== actual) {
    throwBug(`Assertion failed. Expected ${expected} but got ${actual}`, astNode, $el)
    debugger // here so we can diagnose the assertion
    throw new Error(`Assertion failed. Expected ${expected} but got ${actual}. Throwing for stacktrace`)
  }
}
module.exports = {init, throwError, throwBug, showWarning, showLog, showDebuggerData, assert}
