const constructSelector = require('./construct-selector')

let _console = console
let _htmlSourceLookup
let _htmlSourcePath
let _options = {}
let _hasBeenWarned = false

function init(consol, htmlSourceLookup, htmlSourcePath, options) {
  _console = consol
  _htmlSourceLookup = htmlSourceLookup
  _htmlSourcePath = htmlSourcePath
  _options = options
}

function cssSnippetToJson(cssSnippet) {
  // Sometimes we get an array of AST nodes. Just pick the 1st
  if (Array.isArray(cssSnippet) && cssSnippet.length >= 1) {
    cssSnippet = cssSnippet[0]
  }
  // matches input format for https://github.com/feross/snazzy
  if (cssSnippet && cssSnippet.loc) {
    // Commented out the end lookup because when the CSS ast is rewritten with the original source coordinates this data is not present most of the time
    const {source: cssSourcePath, start: {line: startLine, column: startColumn}/*, end: {line: endLine, column: endColumn}*/} = cssSnippet.loc
    return {filename: cssSourcePath, location: [startLine, startColumn + 1]} // columns start with 0 (lines start with 1)
  } else {
    return {filename: 'unknownCSSFile', location: [0, 0], additional: JSON.stringify(cssSnippet)}
  }
}


// Generate pretty messages with source lines for debugging
function sendLintMessage(severity, message, cssSnippet, $el, additionalCssSnippet) {
  _console.info(JSON.stringify({
    type: 'LINT',
    severity: severity,
    message: message,
    css_file_info: cssSnippet && cssSnippetToJson(cssSnippet),
    additional_css_file_info: additionalCssSnippet && cssSnippetToJson(additionalCssSnippet),
    html_file_info: $el && $el[0] && htmlLocation($el[0])
  }))
}



function htmlLocation(el) {
  if (el) {
    if (_htmlSourceLookup) {
      const locationInfo = _htmlSourceLookup(el)
      function getLocationString() {
        if (locationInfo.line !== null && typeof(locationInfo.line) !== 'undefined') {
          return {filename: _htmlSourcePath, location: [locationInfo.line, locationInfo.col]}
        } else {
          const selector = constructSelector(el)
          return {filename: _htmlSourcePath, location: selector}
        }
      }
      if (locationInfo) {
        // ELements like <body> do not have location information
        const htmlDetails = getLocationString()
        return htmlDetails
      }
    }
    // no lookup info present. It could be an element that was generated by CSS
    if (el.__cssLocation) {
      return cssSnippetToJson(el.__cssLocation)
    } else {
      const selector = constructSelector(el)
      return {filename: _htmlSourcePath, location: selector}
    }
  } else {
    return 'unknown'
  }
}

function showError(message, cssSnippet, $el) {
  sendLintMessage('ERROR', message, cssSnippet, $el)
}

function throwError(message, cssSnippet, $el, err) {
  showError(message, cssSnippet, $el)
  if (err) {
    throw err
  } else {
    throw new Error(message)
  }
}

function showBug(message, cssSnippet, $el) {
  sendLintMessage('BUG', message, cssSnippet, $el)
}

function throwBug(message, cssSnippet, $el, err) {
  showBug(message, cssSnippet, $el)
  debugger
  if (err) {
    throw err
  } else {
    throw new Error(message)
  }
}

const displayedWarningCache = {} // Only show a warning for a particular source line once. Otherwise it is annoying
function showWarning(message, cssSnippet, $el, additionalCssSnippet) {
  const key = `${cssSnippetToJson(cssSnippet)} | ${message}`
  if (!displayedWarningCache[key] || _options.verbose) {
    sendLintMessage('WARN', message, cssSnippet, $el, additionalCssSnippet)
    displayedWarningCache[key] = true
  }
}

function showLog(message, cssSnippet, $el) {
  sendLintMessage('LOG', message, cssSnippet, $el)
}


function showDebuggerData($currentEl, debugMatchedRules, debugAppliedDeclarations, debugSkippedDeclarations, $debuggingEl, toBrowserSelector) {
  _console.info(JSON.stringify({
    type: 'DEBUG_ELEMEMT',
    html_file_info: htmlLocation($debuggingEl[0]),
    context_html_file_info: ($currentEl[0] !== $debuggingEl[0]) && htmlLocation($currentEl[0]), // only include when context is different than the current element
    selectors: debugMatchedRules.map((matchedRule) => {
      const {rule, selector} = matchedRule.getRule()
      return {
        css_file_info: cssSnippetToJson(rule),
        browser_selector: toBrowserSelector(selector, true /*includePseudoElements*/)
      }
    }),
    declarations: debugAppliedDeclarations.map(({declaration, vals}) => {
      return {
        css_file_info: cssSnippetToJson(declaration.astNode),
        name: declaration.astNode.property,
        value:
            // vals is a 2-dimensional array
            vals.map((val) => {
              return val.map((v2) => {
                if (typeof v2 === 'string') {
                  return v2
                } else if (typeof v2 === 'number') {
                  return v2
                } else if (v2.jquery) {
                  return v2.toArray().map((el) => {
                    return htmlLocation(el)
                  })
                } else {
                  debugger
                  return v2
                }
              })
            })
      }
    }),
    skipped_declarations: debugSkippedDeclarations.map(({declaration, unevaluatedVals}) => {
      return {
        css_file_info: cssSnippetToJson(declaration.astNode),
        name: declaration.astNode.property,
        unevaluated_vals: unevaluatedVals
      }
    })
  }))
}


function sendElementCount(count) {
  _console.info(JSON.stringify({
    type: 'ELEMENT_COUNT',
    count: count
  }))
}


function sendProgressStart(details) {
  _console.info(JSON.stringify({
    type: 'PROGRESS_START',
    details
  }))
}

function sendProgressTick(details) {
  _console.info(JSON.stringify({
    type: 'PROGRESS_TICK',
    details
  }))
}

function sendProgressEnd(details) {
  _console.info(JSON.stringify({
    type: 'PROGRESS_END',
    details
  }))
}


module.exports = {init, throwError, throwBug, showWarning, showError, showBug, showLog, showDebuggerData, sendElementCount, sendProgressStart, sendProgressTick, sendProgressEnd}
